#!/usr/bin/env bash
set -euo pipefail

###############################################################################
# HARD CONFIG — works from anywhere
###############################################################################

PROJECT_ROOT="$HOME/Dev/krisyotam.com"

DATA_DIR="$PROJECT_ROOT/data"
CONTENT_DIR="$PROJECT_ROOT/app/(content)"

###############################################################################
# REQUIREMENTS
###############################################################################

command -v jq >/dev/null 2>&1 || {
  echo "ERROR: jq is required."
  exit 1
}

###############################################################################
# OPTIONAL TOOLS
###############################################################################

have() { command -v "$1" >/dev/null 2>&1; }

# Defaults (can be overridden via CLI args)
USE_FZF=true

# Parse simple CLI flags (only --no-fzf / -n for now)
while [[ ${#} -gt 0 ]]; do
  case "$1" in
    --no-fzf|-n)
      USE_FZF=false
      shift
      ;;
    --help|-h)
      cat <<'EOF'
Usage: write [--no-fzf|-n]
  --no-fzf, -n   Disable fzf UI and fall back to numbered selection
EOF
      exit 0
      ;;
    *)
      # ignore unknown args for now
      shift
      ;;
  esac
done

###############################################################################
# HEADER
###############################################################################

print_banner() {
  if have figlet; then
    figlet -f big "KRISYOTAM.COM"
  else
    echo "KRISYOTAM.COM"
  fi

  cat <<'EOF'
est. 2025
Author: Kris Yotam
Research & Writing Environment
EOF
  echo
}

###############################################################################
# CONTENT TYPES
###############################################################################

TYPES=(
  blog cases conspiracies dossiers essays fiction lab lectures lexicon libers
  news notes ocs papers problems progymnasmata proofs reviews shortform
)

###############################################################################
# CORE FUNCTIONS
###############################################################################

choose_type() {
  if have fzf; then
    printf "%s\n" "${TYPES[@]}" | fzf --prompt="type> "
  else
    select t in "${TYPES[@]}"; do
      echo "$t"
      return
    done
  fi
}

list_entries() {
  local type="$1"
  local data_file
  data_file=$(find_data_file "$type") || return 1

  jq -r --arg t "$type" '
    # Prefer explicit keys: $t or ${t}s. If the file itself is an array use it.
    if (type == "array") then .
    elif (.[ $t ]? | type) == "array" then .[$t]
    elif (.[($t + "s")]? | type) == "array" then .[($t + "s")]
    else (to_entries[] | select(.value|type=="array") | .value) end
    | .[]
    | [.title // "", .slug // "", (.category // "")] | @tsv
  ' "$data_file"
}

choose_entry() {
  local type="$1"
  local data_file
  data_file=$(find_data_file "$type") || return 1

  local type="$1"
  local data_file
  data_file=$(find_data_file "$type") || return 1

  if [[ "$USE_FZF" == "true" && $(have fzf && echo yes || echo no) == yes ]]; then
    # compact pretty preview: Title, Preview, Tags (comma-separated), Category, Status
    list_entries "$type" |
      awk -F'\t' '{print $1 " — " $2 "\t" $2 "\t" $3}' |
      fzf --delimiter=$'\t' --with-nth=1 --prompt="entry> " \
          --preview='slug=$(echo {} | awk -F"\t" "{print \$2}"); jq -r --arg s "$slug" ".. | objects | select(.slug? == \$s) | {title: .title, preview: (.preview // ""), tags: (.tags // []), category: (.category // ""), status: (.status // "")} | [ ("Title: " + (.title // "")), ("Preview: " + (.preview // "")), ("Tags: " + ((.tags // []) | join(", "))), ("Category: " + (.category // "")), ("Status: " + (.status // "")) ] | .[]" "$data_file" | sed -n "1,200p"' |
      cut -f2
  else
    # numbered selection fallback (either fzf missing or user requested no-fzf)
    list_entries "$type" > /tmp/.write-list-$$ || return 1
    local i=1
    mapfile -t lines < /tmp/.write-list-$$
    for line in "${lines[@]}"; do
      IFS=$'\t' read -r title slug _ <<<"$line"
      printf "%3d) %s — %s\n" "$i" "$title" "$slug"
      ((i++))
    done
    echo
    read -rp "Choose number (or q): " sel
    [[ "$sel" =~ ^[Qq]$ ]] && return 0
    [[ "$sel" =~ ^[0-9]+$ ]] || return 1
    printf "%s" "$(printf "%s\n" "${lines[@]}" | sed -n "${sel}p" | awk -F'\t' '{print $2}')"
  fi
}

resolve_file() {
  local type="$1"
  local slug="$2"
  local data_file
  data_file=$(find_data_file "$type") || return 1

  local cat
  cat=$(jq -r --arg s "$slug" '.. | objects | select(.slug? == $s) | .category // empty' "$data_file")

  local base="$CONTENT_DIR/$type/content"
  [[ -n "$cat" ]] && base="$base/$cat"

  for ext in mdx md markdown; do
    [[ -f "$base/$slug.$ext" ]] && {
      echo "$base/$slug.$ext"
      return 0
    }
  done
  return 1
}

find_data_file() {
  local type="$1"
  local candidates=(
    "$DATA_DIR/$type/$type.json"
    "$DATA_DIR/$type/${type}s.json"
    "$DATA_DIR/${type}.json"
    "$DATA_DIR/${type}s.json"
    "$DATA_DIR/$type.json"
  )

  for f in "${candidates[@]}"; do
    [[ -f "$f" ]] || continue
    # quick check: file is valid JSON
    if jq empty "$f" >/dev/null 2>&1; then
      echo "$f"
      return 0
    fi
  done
  return 1
}

open_file() {
  local file="$1"

  if have flatpak; then
    flatpak run org.gnome.gitlab.somas.Apostrophe "$file" &>/dev/null &
    disown
  elif [[ -n "${EDITOR:-}" ]]; then
    "$EDITOR" "$file" &
  else
    xdg-open "$file" &
  fi
}

###############################################################################
# MAIN LOOP
###############################################################################

main() {
  clear
  print_banner

  while true; do
    type=$(choose_type) || exit 0
    [[ -z "$type" ]] && exit 0

    slug=$(choose_entry "$type") || continue
    [[ -z "$slug" ]] && continue

    file=$(resolve_file "$type" "$slug")

    if [[ -z "$file" ]]; then
      echo "File not found for $slug"
      read -rp "Press Enter..."
      continue
    fi

    open_file "$file"
  done
}

main
