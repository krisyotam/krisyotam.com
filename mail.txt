Understood. I’ll conduct a deep investigation of your entire repository to identify all current issues, determine a stable and appropriate Next.js version to lock into, and outline what needs to be fixed or stabilized so your site remains permanently functional without requiring any future upgrades. I’ll get started and update you as soon as I have actionable findings.


# Comprehensive Stability Audit and Fix Plan for **krisyotam.com**

## 1. Lock Next.js to a Stable Version

**Current State:** The project is using Next.js **14.2.26** with a caret (`^14.2.26`) in *package.json*. This means any minor 14.x update could be picked up, and Next 15 (which introduces major changes) is available but likely not fully stable for your code.
**Recommendation:** **Freeze Next.js at v14.2.26** (or the latest 14.x patch known to work) and remove the caret. For example, set `"next": "14.2.26"` in *package.json*. This ensures you stick with the proven Next 14 app directory features and avoid breaking changes from Next 15 or beyond. Next 14 supports the `app/` directory and MDX as used in your code, so it’s a safe target. Locking the exact version means no surprises from future updates – you’ll only upgrade if you explicitly choose to.

**Rationale:** Next 14.x has been tested with your code structure (app router, MDX integration, etc.), whereas Next 15+ could introduce instability. By pinning to 14.2.26 permanently, you ensure the framework’s behavior won’t change under you. This aligns with the goal of no future framework evolution.

## 2. Pin All Dependencies to Fixed Versions

**Current State:** Many dependencies in *package.json* are set to `"latest"` or broad ranges, which is risky for long-term stability. For example, Apollo Client, Radix UI Slot, GraphQL, Next-Themes, React Window, and others are on `"latest"`. This means each new install could pull in newer versions that might introduce breaking changes or bugs.
**Recommendation:** **Replace all `"latest"` (and overly broad ranges) with specific versions** that are known to work. Use the versions currently in your lock file or node\_modules as the locked reference. For example:

* Set `"@apollo/client"` to the exact version it currently resolved to (instead of `"latest"`). Do the same for `"@radix-ui/react-slot"`, `"graphql"`, `"graphql-ws"`, `"next-themes"`, `"react-window"`, etc..
* Pin devDependencies as well (e.g. `@types/react`, which is `"latest"` now, and TypeScript which is `"^5"`). Use exact versions (like `"@types/react": "18.x.x"`, `"typescript": "5.x.x"`) that you’ve tested.

After editing *package.json* with exact versions, reinstall to update the lock file. This way, every build uses the same package versions moving forward.

**Rationale:** Pinning versions eliminates the chance of an untested upgrade sneaking in. This is crucial for a “permanently stable” setup. By locking all dependencies (especially those marked latest) to their current stable versions, you avoid future incompatibilities or deprecations. In short, the code will always run against the known-good library versions it was developed with.

## 3. Repair Build and TypeScript Issues (Remove Ignore Flags)

**Current State:** The Next.js config is currently suppressing build errors and lint checks:

* `eslint.ignoreDuringBuilds: true` and `typescript.ignoreBuildErrors: true` are set in *next.config.mjs*.
  This means the project is likely building despite TypeScript errors or ESLint rule violations. While this may have been a temporary relief under time pressure, it hides real problems that could affect runtime behavior or future refactoring.

**Recommendation:** **Turn these checks back on after fixing the underlying errors.** Specifically:

* Remove or set `ignoreDuringBuilds: false` and `ignoreBuildErrors: false` in the Next config (or simply delete those lines). This will cause the build to fail if any TypeScript errors remain – which is good, since we want to fix them, not ignore them.

* Go through the TypeScript errors that surface. Common issues likely include:

  * **MDX module typing:** The dynamic MDX imports (e.g. `import(\`@/app/notes/content/\${year}/\${slug}.mdx\`)`in your note page:contentReference[oaicite:10]{index=10}) might have caused TS complaints. Solve this by adding a global type declaration for`.mdx`modules. For example, create a`custom.d.ts`(and include it in tsconfig) with`declare module "\*.mdx";\`. This tells TypeScript that importing an MDX file yields a React component, resolving those errors.
  * **JSON imports:** Ensure `resolveJsonModule` is enabled in your TS config so that lines like `import notesData from "@/data/quick-notes.json";` are understood. If it’s not already on, add `"resolveJsonModule": true` in *tsconfig.json*. Then you can optionally define interfaces for these JSON data shapes for stronger typing (e.g. define a `Note` type for entries of quick-notes).
  * **Any implicit `any` or type mismatches:** Address any remaining type errors by updating function signatures or adding type casts where appropriate. For example, ensure functions like `getPostsByTag` and others return the proper types expected by their usage. The goal is to have `npm run build` pass without ignores.

* After fixes, run the build and lint. If ESLint flags any real issues (unused variables, etc.), consider cleaning them up for code health. However, focus on error-level issues; stylistic lint rules can remain relaxed if they don’t impact stability.

**Rationale:** Re-enabling type and lint checks forces the code to be sound, which prevents potential runtime errors (e.g. undefined values, misused APIs). By fixing the errors rather than bypassing them, you reinforce the project’s correctness. This makes the codebase easier to maintain and reduces the risk of subtle bugs that TypeScript could have caught. In short, the build should only succeed when everything is truly OK – this gives peace of mind for long-term stability.

## 4. Merge and Simplify Next.js Configuration (Remove Experimental Flags)

**Current State:** The Next.js config is split between *next.config.mjs* and a *v0-user-next.config.js*, with some redundant or experimental settings:

* *base config* (next.config.mjs) defines custom webpack tweaks (MDX handling, alias) and includes experimental settings like `webpackBuildWorker`, `parallelServerBuildTraces`, etc..
* *user config* (v0-user-next.config.js) sets `reactStrictMode: true`, `swcMinify: true`, `output: "standalone"`, and also enables experiments `serverActions: true` and `mdxRs: true`. It also defines a webpack function to add a canvas externals hack.
* These two configs are merged at runtime, but **the webpack merge is not handled properly** – the user config’s webpack function **overrides** the base webpack settings rather than extending them. This means the custom alias for `next/image` and the raw MDX loader from the base config are likely being lost currently.

**Recommendations:** Simplify and consolidate the config for clarity and stability:

* **Unify into a single config file.** Instead of dynamically importing and merging, carry over the needed parts from *v0-user-next.config.js* into *next.config.mjs* and remove the import logic. For example, set `reactStrictMode: true`, `swcMinify: true`, and `output: "standalone"` directly in the exported config object. These are important for runtime behavior (Strict Mode for highlighting issues in development, SWC minify for smaller builds, and standalone output for deployment portability).

* **Handle the webpack customization in one place:** Incorporate the canvas external fix into the base webpack function so nothing is lost. For instance:

  ```js
  webpack(config) {
      // Existing alias and MDX rule:
      config.resolve.alias = { ...(config.resolve.alias||{}), "next/image$": "next/future/image" };
      config.module.rules.push({ test: /\.mdx\?raw$/, type: 'asset/source' });
      // Include canvas in externals to avoid bundling it
      config.externals = [...(config.externals || []), { canvas: "canvas" }];
      return config;
  }
  ```

  This way, you can remove the separate user webpack override and keep all needed tweaks. Verify that after this change, the new image alias and MDX raw imports still work. (Consider whether the `next/future/image` alias is still necessary in Next 14 – see note below.)

* **Turn off unused experiment flags:** Unless you are actively using an experimental feature, it’s safer to disable it. In particular:

  * **Server Actions:** You have `experimental.serverActions: true` set but no form actions defined in the code. Disable this to avoid any unpredictable behavior (it won’t affect your app since you’re not using the feature).
  * **MDX Rust compiler (mdxRs):** This is an experimental MDX compiler in Next. If your MDX content is building fine, this might not be needed. You can try turning it off to rely on the stable MDX integration via `@next/mdx`. (If you find build performance suffers or any MDX parsing issues arise after disabling, you can keep it on – but generally, fewer experiments equal fewer surprises.)
  * The other experimental flags (webpackBuildWorker, parallelServerCompiles, etc.) were likely enabled to speed up builds. If you haven’t experienced issues with them, you can leave them on. But be aware they are experimental; if any build instability is observed (e.g. inconsistent builds or memory spikes), consider disabling these as well. It might slightly slow builds but improve reliability.

* **Verify the Image component setup:** You currently alias `next/image` to the new `next/future/image`, presumably to use the newer improved Image component. In Next 13+ this newer image is usually the default. Double-check if this alias is still needed under Next 14. If not needed, you can remove the alias to reduce complexity (and remove the import of the deprecated `next/future/image` path). Also note that you have `images.unoptimized: true` set, which is fine (it disables Next’s built-in image optimization, useful since you plan to possibly self-host). Just ensure all your `<Image>` usage works as expected after any alias changes.

**Rationale:** A single, clear Next.js config file will be much easier to maintain. Merging logic introduced risk (like the webpack override issue). By integrating the user config settings into the main config, you eliminate that class of bug. Removing or reducing experimental flags means you’re sticking to battle-tested Next.js features only – exactly what we want for long-term stability. The resulting config will explicitly contain all the intended settings (strict mode, standalone output, etc.) with no hidden interactions, making behavior predictable across environments.

## 5. Fix Broken Links and Missing API Endpoints

**Current State:** Most front-end routes and pages are implemented, but a few dynamic endpoints used by the client are either missing or incomplete:

* The **404 suggestion script** on the custom Not Found page is not being loaded because the endpoint `/api/get-script` is not implemented. In *app/not-found.tsx*, the code tries to inject a script from `/api/get-script?t=...` (with a timestamp to bypass cache). Currently, this will return 404, meaning the helpful suggestions logic (in `404-suggester.js`) never runs.
* The 404 suggestion script itself expects a generic data API at `/api/data?file=...` for various JSON files (pages, posts, notes, tags, etc.). It looks like such an API endpoint is not present yet. (Instead, you have individual APIs like `/api/others`, `/api/poems`, etc., and likely need a catch-all for the rest.)

**Recommendations:**

* **Implement the `/api/get-script` endpoint** to serve the 404 suggestion script. For example, create *app/api/get-script/route.ts* that reads the `scripts/404-suggester.js` file from the file system and returns its content with `Content-Type: application/javascript`. Ensure to use `NextResponse` or `new Response` correctly. This will allow the `<script src="/api/get-script?t=...">` injection to succeed. After implementing, test by visiting any nonexistent URL and confirming that suggestions populate (and check the console for the “404-suggester script injected” log to verify it loaded).

* **Provide an API or static access for JSON data files** used in suggestions. E.g., the script calls `/api/data?file=feed.json` and others. You have two ways to handle this:

  * *Option A:* Implement a general **`/api/data`** route. This route would read the `file` query parameter, validate it against a whitelist of allowed JSON filenames (to prevent arbitrary file access), and respond with that file’s JSON content. This single endpoint can handle `feed.json`, `page-directory.json`, `quick-notes.json`, `tags.json`, `series.json`, `category-data.json`, `poems.json`, etc. (the files referenced in the suggester). This keeps things DRY, but do carefully restrict `file` to known values (perhaps use a simple allow-list or check that the path contains no slashes) for security.
  * *Option B:* If you prefer not to use a query param API, you could expose these files as static assets. For example, move the needed JSON files into the **public** folder (or configure Next to serve the `data/` folder statically). Then adjust `dataUrls` in `404-suggester.js` to point directly to those (e.g. `/data/feed.json` instead of `/api/data?file=feed.json`). However, since you already have some APIs reading from `data/`, Option A might integrate more nicely with your setup.
  * In either case, after implementation, test that the 404 page fetches all required JSON (you can simulate by opening the browser console on a 404 page and ensuring no fetch requests fail). This will generate a list of closest matches on 404s, enhancing UX without needing future framework changes.

* **Audit internal links in content:** Ensure that all links used in your markdown/MDX and components correspond to actual pages. For example, the home bio mentions `/about#areas-of-interest` and `/colophon` – confirm that these exist (perhaps they are static MDX pages or anchors). Similarly, the home page mentions a blog post `/blog/2025/on-myself` – verify that *app/blog/2025/on-myself/page.mdx* is present (so the link isn’t broken). It appears you’ve migrated most content to MDX and JSON, so just double-check none of the older Ghost-era links (like `/post/slug` or external ghost URLs) remain. The middleware is already handling old `/post/*` URLs by redirecting to the `/blog/[year]/[slug]` structure using the feed data – which is great. Keep the middleware in place as it ensures any legacy links or external references to your old routes still find the correct page.

* **Verify category/tag pages:** You implemented dynamic category and tag indexes (e.g. `/categories`, `/category/[slug]`, `/tag/[slug]`), which is excellent for preventing broken links in navigation. Test these pages to confirm they list content properly and handle empty states (your code already returns 404 if no posts for a tag, and shows “No categories/tags found” if none). These should be working, but it’s worth clicking through your site to ensure all “directory” pages (Tags, Categories, Notes, Archive, etc.) render without runtime errors. If any directory is unimplemented but linked, either implement it or remove the link to avoid user-facing 404s.

**Rationale:** Every user-facing link or script should resolve correctly in a truly stable site. By adding the missing API routes for the 404 helper and data files, you eliminate those `fetch` errors and fully realize the intended functionality (making the site more self-sufficient). This also prevents console errors from piling up, which can obscure real issues. In short, plugging these gaps ensures the site behaves as expected in all cases, even for missing pages.

## 6. Harden Content Loading & Error Handling

**Current State:** The site loads most content from static JSON/MDX, which is good for stability, but there are a few places to harden:

* The **home page** (`HomeWrapper` server component) tries multiple fallbacks when loading posts and the bio. If `data/feed.json` fails to read or is empty, it logs an error and inserts a placeholder post. Similarly, if the home bio MDX file cannot be read, it catches and uses a default bio string. These measures prevent crashes, but we should ensure these scenarios rarely occur.
* The site still includes utility functions for live Ghost CMS fetching (e.g. in *utils/ghost.ts*) and possibly uses them for “Now” or other sections (like poems previously). Calling external APIs at request time could lead to timeouts or failures outside your control. However, it looks like you’ve mostly replaced Ghost content with static files (feed, others.json, mybooks.json, poems.json, etc.), meaning the ghost fetch functions might no longer be actively used in pages.
* Some client-side components fetch data and only log errors on failure. For example, `OthersClient` fetches `/api/others` and if it fails, it `console.error("Error fetching others entries:", error)` but still renders an empty state with no message. The Tags/Categories pages, by contrast, catch errors and display a user-friendly “Failed to load” message.

**Recommendations:**

* **Ensure required data files are present and up-to-date.** The build or deploy process should include generating or validating key JSON files like *feed.json*, *tags.json*, *category-data.json*, etc. If you have a script to produce these (maybe exporting from Ghost or aggregating MDX frontmatter), integrate it so that you’re never deploying without fresh data. This prevents the home page “no posts” fallback from ever triggering under normal circumstances. Ideally, each deploy should bundle an updated *feed.json* reflecting the MDX posts (or your latest content snapshot from Ghost, if you still use it for writing then export). Keeping this in sync means the home page and other listings always have content and don’t hit the warning state.
* **Remove runtime reliance on Ghost API:** If not already done, disable or delete any code that fetches from `kris-yotam.ghost.io` at runtime. For instance, the `getPosts()/getBooks()/getPoemBySlug()` in *utils/ghost.ts* and *utils/poemGhost.ts* should no longer be invoked by pages. Instead, all content should funnel through static files or on-demand revalidation. Given you have *data/poems.json* and an `/api/poems` endpoint, it seems you’ve exported poems from Ghost as well. Thus, you can likely **remove the Ghost API key and URL configs** from the code (or at least ensure they are not used), which eliminates a potential point of failure. This also improves security (no secret keys in the repo, though your Ghost content key isn’t highly sensitive, it’s still best not to depend on it).
* **Improve client-side error handling:** For components like `OthersClient` (and any similar ones), consider displaying a message to the user if the fetch fails. You could set a state like `errorLoading=true` in the catch, and render a fallback UI (“Failed to load entries. Please refresh.”) instead of just an empty list. This way the user isn’t left confused if your `/api/others` ever had an issue. This is a small UX enhancement that doesn’t affect framework stability but does make the site behavior more robust.
* **Test all dynamic routes with edge cases:** Try hitting some known 404 scenarios (e.g., a tag slug that doesn’t exist, a blog post URL with a typo) and ensure the not-found page shows the suggestions and a random quote (once the above fixes are in place). Since you already built a custom 404 page with thoughtful features, we want to ensure it always works. The random quote API `/api/random-quote` is implemented and should be returning a quote from *header-quotes.json* – verify that works in production and perhaps add a cache or fallback if needed (though it’s pretty straightforward and should be fine given it’s just reading a local JSON).

**Rationale:** These steps further reduce any surprise failures at runtime. By relying solely on local data and handling errors gracefully, the site becomes resilient: even if something is missing or goes wrong, the user either sees a helpful message or the site self-recovers using defaults. Removing calls to external services (Ghost) means once the site is deployed with its data, it’s self-contained and not impacted by network issues or API changes. The result is a site that **always “just works”** with the content it has, which is the ultimate goal under a no-upgrades, no-hassle philosophy.

## 7. Remove Unused or Risky Dependencies

**Current State:** The project includes some packages that might no longer be needed or that are outdated/deprecated: one notable example is **`subscriptions-transport-ws`**, which is marked `"latest"` in package.json. This library has been superseded by `graphql-ws` (which you also include) and is no longer maintained. Keeping it could introduce security or compatibility issues, especially if it ever gets installed as “latest” (which could be a version mismatched to your GraphQL client). There may be other similar cases (for instance, old polyfills or duplicate libs).

**Recommendation:** Audit the **usage** of any suspect dependencies and remove them if they’re not actively used:

* **`subscriptions-transport-ws`:** If you aren’t using this for any GraphQL subscriptions (likely not, if you’ve moved to `graphql-ws`), remove it from package.json entirely. This avoids any chance of conflict or the need to update it.
* Look for other libraries marked “latest” that you might not need. For example, `escodegen`, `acorn`, `cmdk` etc., are these directly used in your code or were they transitive dependencies? If you added them intentionally, pin them; if not actually in use, they can be removed to slim the project and its attack surface.
* Similarly, double-check for any overlapping functionality (e.g., both `@apollo/client` and some other GraphQL client? or multiple markdown libraries). Removing clutter will make long-term maintenance easier.

**Rationale:** Each dependency is a potential point of breakage or required upgrade. By trimming unused packages, you reduce the future workload and eliminate classes of errors. The leaner the dependency graph, the fewer things can go wrong as environments change. This also speeds up installs and builds slightly. Overall, it’s part of stabilizing the foundation – use only what you need, and make sure what you use is locked to a working version (as covered in Step 2).

## 8. Final Verification and Long-Term Considerations

Once the above changes are implemented, do a thorough final test: run the dev server and build, click through every page, and check the console for errors. You should see that:

* The build passes with no TypeScript errors or unhandled warnings.
* No deprecation warnings or peer dependency conflicts appear in the console (after pinning versions, this should be clean).
* All pages (home, posts, notes, “Others”, tags, categories, etc.) load correctly and dynamic bits (search if any, toggles, etc.) work.
* The 404 page now shows suggestions and a quote, confirming the new APIs are functioning.
* Deployment (whether on Vercel or standalone) works without special handling. With `output: "standalone"` now in the main config, the Next build outputs a self-contained bundle. This is good if you later move off Vercel – you can run `npm run build` and then `npm start` to serve the app, or dockerize it easily. Do a test of `npm run build && npm start` locally to ensure the app runs in production mode with no runtime issues.

Finally, going forward **avoid updating any framework or library unless absolutely necessary**. With everything locked, dependabot or npm audit might flag updates – resist the urge to update “just because”. Security patches in minor libs are the only exception, but even then, evaluate if they truly affect your site. The philosophy here is to treat this codebase as “frozen” on a known-good stack. Document the versions you froze (perhaps in the README or a comment in package.json) so future maintainers know the intended state.

By following this plan, **the site will be stable, predictable, and low-maintenance**. You’ll have eliminated common sources of bugs (version drift, unhandled errors, external API reliance) and can focus on content and minor tweaks without worrying about breaking changes. This provides peace of mind that your site can run reliably for the long haul without chasing framework upgrades.

## **Summary of Key Fixes** (Checklist)

* **Next.js:** Lock to **v14.2.26** (no caret) and commit that version.
* **Dependencies:** Pin all to specific versions (replace all “latest” versions with exact numbers based on current working versions). Remove any packages not in use (e.g. `subscriptions-transport-ws` if unused).
* **Next Config:** Merge user config into one config. Enable `reactStrictMode`, `swcMinify`, and `output: "standalone"` in *next.config.mjs* (carry from user config). Incorporate the webpack customizations together (don’t override aliases) – ensure both the MDX loader and canvas externals are applied. Turn **off** experimental flags like `serverActions` unless needed.
* **Build Validation:** Remove `ignoreBuildErrors` and lint ignores. Add missing type definitions (for MDX modules, etc.) so that `npm run build` passes cleanly.
* **Broken 404 Helpers:** Implement `/api/get-script` to serve the `404-suggester.js` script and add an `/api/data` endpoint (or equivalent static access) so all JSON files requested by the 404 script can be fetched.
* **Content Data:** Ensure all content JSON (feed, tags, etc.) are present and updated as part of your deployment workflow. Minimize any runtime calls to Ghost – rely on those static files instead. Remove Ghost API usage code if it’s now redundant.
* **Error Handling:** Improve client-side error handling for data-fetching components (e.g., show a message if `/api/others` fails, rather than failing silently). This makes the site behavior more user-friendly under failure conditions.
* **Testing:** Test all pages and dynamic routes after changes. Verify no console errors in browser or server. The site should function identically to before (aside from now working better on 404s), but with a more robust backend.

By executing all the above changes, your project will be locked in a stable state. You will not need to chase framework updates, and the site will be far less prone to random breakage. Each piece of the stack is frozen and verified, so you can confidently focus on writing content and know the platform will remain solid.&#x20;
